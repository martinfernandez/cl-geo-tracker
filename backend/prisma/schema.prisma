generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String             @id @default(uuid())
  email                   String             @unique
  password                String
  name                    String
  areaOfInterestLatitude  Float?
  areaOfInterestLongitude Float?
  areaOfInterestRadius    Float?             @default(5000) // meters, max 10000

  // Privacy settings
  showName                Boolean            @default(true)
  showEmail               Boolean            @default(false)
  showPublicEvents        Boolean            @default(true)

  // Push notifications
  expoPushToken           String?

  createdAt               DateTime           @default(now())
  updatedAt               DateTime           @updatedAt
  devices                 Device[]
  events                  Event[]
  reactions               Reaction[]
  comments                Comment[]
  commentLikes            CommentLike[]
  sentNotifications       Notification[]     @relation("NotificationSender")
  receivedNotifications   Notification[]     @relation("NotificationReceiver")
  createdAreas            AreaOfInterest[]   @relation("AreaCreator")
  areaMemberships         AreaMembership[]
  sentAreaInvitations     AreaInvitation[]   @relation("InvitationSender")
  receivedAreaInvitations AreaInvitation[]   @relation("InvitationReceiver")

  // Messaging relations
  sentMessages            Message[]          @relation("MessageSender")
  receivedMessages        Message[]          @relation("MessageReceiver")
  conversations           ConversationParticipant[]

  // Group relations
  createdGroups              Group[]            @relation("GroupCreator")
  groupMemberships           GroupMembership[]
  sentGroupInvitations       GroupInvitation[]  @relation("GroupInvitationSender")
  receivedGroupInvitations   GroupInvitation[]  @relation("GroupInvitationReceiver")
  phoneDevice                PhoneDevice?

  // Found object chat relations
  ownedFoundChats            FoundObjectChat[]  @relation("OwnedFoundChats")
  finderFoundChats           FoundObjectChat[]  @relation("FoundChats")
}

enum DeviceType {
  GPS_TRACKER    // Dispositivo JX10 con IMEI
  TAGGED_OBJECT  // Objeto con QR sin GPS (llaves, billetera, etc)
}

model Device {
  id        String     @id @default(uuid())
  type      DeviceType @default(GPS_TRACKER)
  imei      String?    @unique  // Opcional para TAGGED_OBJECT
  name      String?
  color     String?    @default("#007AFF") // Color for map markers
  userId    String?
  user      User?      @relation(fields: [userId], references: [id])

  // QR Code settings
  qrCode    String     @unique @default(uuid())  // Código único para QR
  qrEnabled Boolean    @default(true)  // Si el QR está activo

  // Battery info (for JX10 GPS devices)
  batteryLevel     Int?       // 0-100 percentage
  batteryUpdatedAt DateTime?  // Last time battery was reported
  lastPositionAt   DateTime?  // Last time a position was received

  // Geofence lock settings
  isLocked      Boolean  @default(false)
  lockLatitude  Float?
  lockLongitude Float?
  lockRadius    Float    @default(0)  // meters, 0 = no movement allowed
  lockedAt      DateTime?
  lastAlertAt   DateTime?  // To prevent spam notifications

  // GPS reporting interval settings (for JX10 devices)
  activeInterval  Int      @default(30)   // seconds - interval when device has active event
  idleInterval    Int      @default(600)  // seconds - interval when no active events (10 min)
  currentInterval Int?                    // current configured interval on device

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  positions Position[]
  events    Event[]
  foundChats FoundObjectChat[]  // Chats de objetos encontrados

  @@index([userId])
  @@index([isLocked])
  @@index([qrCode])
  @@index([type])
}

model Position {
  id        String   @id @default(uuid())
  deviceId  String
  device    Device   @relation(fields: [deviceId], references: [id])
  latitude  Float
  longitude Float
  altitude  Float?
  speed     Float?
  heading   Float?
  timestamp DateTime
  createdAt DateTime @default(now())

  @@index([deviceId])
  @@index([timestamp])
}

model Event {
  id               String         @id @default(uuid())
  deviceId         String?
  device           Device?        @relation(fields: [deviceId], references: [id])
  phoneDeviceId    String?
  phoneDevice      PhoneDevice?   @relation(fields: [phoneDeviceId], references: [id])
  userId           String
  user             User           @relation(fields: [userId], references: [id])
  groupId          String?
  group            Group?         @relation(fields: [groupId], references: [id], onDelete: SetNull)
  type             EventType
  description      String
  latitude         Float
  longitude        Float
  status           EventStatus    @default(IN_PROGRESS)
  isPublic         Boolean        @default(true)
  isUrgent         Boolean        @default(false)
  realTimeTracking Boolean        @default(false)
  imageUrl         String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  reactions        Reaction[]
  comments         Comment[]
  conversations    Conversation[]

  @@index([deviceId])
  @@index([phoneDeviceId])
  @@index([userId])
  @@index([groupId])
  @@index([createdAt])
  @@index([isPublic, status])
  @@index([latitude, longitude])
  @@index([isUrgent, status])
  @@index([realTimeTracking, status])
}

enum EventType {
  GENERAL
  THEFT
  LOST
  ACCIDENT
  FIRE
}

enum EventStatus {
  IN_PROGRESS
  CLOSED
}

model Reaction {
  id        String   @id @default(uuid())
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

model Comment {
  id              String        @id @default(uuid())
  eventId         String
  event           Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  content         String
  parentCommentId String?
  parentComment   Comment?      @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies         Comment[]     @relation("CommentReplies")
  likes           CommentLike[]
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([eventId])
  @@index([userId])
  @@index([parentCommentId])
}

model CommentLike {
  id        String   @id @default(uuid())
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
}

model Notification {
  id         String           @id @default(uuid())
  type       NotificationType
  senderId   String?
  sender     User?            @relation("NotificationSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId String
  receiver   User             @relation("NotificationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  eventId    String?
  commentId  String?
  areaId     String?
  chatId     String?          // For found object chats
  content    String
  isRead     Boolean          @default(false)
  createdAt  DateTime         @default(now())

  @@index([receiverId, isRead])
  @@index([createdAt])
}

enum NotificationType {
  EVENT_REACTION
  EVENT_COMMENT
  COMMENT_REPLY
  COMMENT_LIKE
  AREA_INVITATION
  AREA_JOIN_REQUEST
  AREA_JOIN_ACCEPTED
  AREA_EVENT_NOTIFICATION
  NEW_MESSAGE
  GROUP_INVITATION
  GROUP_JOIN_ACCEPTED
  DEVICE_MOVEMENT_ALERT
  FOUND_OBJECT
  FOUND_OBJECT_MESSAGE
}

model AreaOfInterest {
  id          String              @id @default(uuid())
  name        String
  description String?
  latitude    Float
  longitude   Float
  radius      Float               // meters
  visibility  AreaVisibility      @default(PUBLIC)
  creatorId   String
  creator     User                @relation("AreaCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  members     AreaMembership[]
  invitations AreaInvitation[]
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  @@index([creatorId])
  @@index([visibility])
  @@index([name])
  @@index([latitude, longitude])
}

enum AreaVisibility {
  PUBLIC              // Searchable, anyone can join
  PRIVATE_SHAREABLE   // Searchable, requires approval
  PRIVATE             // Not searchable, invite-only
}

model AreaMembership {
  id                   String         @id @default(uuid())
  areaId               String
  area                 AreaOfInterest @relation(fields: [areaId], references: [id], onDelete: Cascade)
  userId               String
  user                 User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  role                 MemberRole     @default(MEMBER)
  notificationsEnabled Boolean        @default(true)
  newEventsCount       Int            @default(0)
  lastSeenAt           DateTime       @default(now())
  createdAt            DateTime       @default(now())

  @@unique([areaId, userId])
  @@index([areaId])
  @@index([userId])
}

enum MemberRole {
  ADMIN
  MEMBER
}

model AreaInvitation {
  id         String             @id @default(uuid())
  areaId     String
  area       AreaOfInterest     @relation(fields: [areaId], references: [id], onDelete: Cascade)
  senderId   String?
  sender     User?              @relation("InvitationSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId String
  receiver   User               @relation("InvitationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  status     InvitationStatus   @default(PENDING)
  type       InvitationType     @default(INVITATION)
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  @@unique([areaId, receiverId, status])
  @@index([areaId])
  @@index([receiverId, status])
  @@index([senderId])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum InvitationType {
  INVITATION      // Creator invites user
  JOIN_REQUEST    // User requests to join
}

model Conversation {
  id            String                      @id @default(uuid())
  eventId       String?
  event         Event?                      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  groupId       String?                     @unique
  group         Group?                      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  isGroupChat   Boolean                     @default(false)
  participants  ConversationParticipant[]
  messages      Message[]
  lastMessageAt DateTime?
  createdAt     DateTime                    @default(now())
  updatedAt     DateTime                    @updatedAt

  @@index([eventId])
  @@index([groupId])
  @@index([lastMessageAt])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  unreadCount    Int          @default(0)
  lastReadAt     DateTime?
  createdAt      DateTime     @default(now())

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId     String?
  receiver       User?        @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  content        String       @db.Text
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
}

// =====================
// USER GROUPS
// =====================

model Group {
  id           String            @id @default(uuid())
  name         String
  description  String?
  creatorId    String
  creator      User              @relation("GroupCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  members      GroupMembership[]
  invitations  GroupInvitation[]
  events       Event[]
  conversation Conversation?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@index([creatorId])
  @@index([name])
}

model GroupMembership {
  id                     String     @id @default(uuid())
  groupId                String
  group                  Group      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  userId                 String
  user                   User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  role                   MemberRole @default(MEMBER)
  locationSharingEnabled Boolean    @default(false)
  createdAt              DateTime   @default(now())

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

model GroupInvitation {
  id         String           @id @default(uuid())
  groupId    String
  group      Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  senderId   String
  sender     User             @relation("GroupInvitationSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId String?
  receiver   User?            @relation("GroupInvitationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  email      String?          // For non-registered users
  status     InvitationStatus @default(PENDING)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  @@index([groupId])
  @@index([receiverId])
  @@index([senderId])
  @@index([email])
}

model PendingEmailInvitation {
  id        String   @id @default(uuid())
  email     String
  groupId   String
  senderId  String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@unique([email, groupId])
  @@index([email])
}

// =====================
// PHONE DEVICE TRACKING
// =====================

model PhoneDevice {
  id             String          @id @default(uuid())
  userId         String          @unique
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  name           String          @default("Mi Teléfono")
  isActive       Boolean         @default(false)
  lastPositionAt DateTime?
  positions      PhonePosition[]
  events         Event[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@index([userId])
  @@index([isActive])
}

model PhonePosition {
  id            String      @id @default(uuid())
  phoneDeviceId String
  phoneDevice   PhoneDevice @relation(fields: [phoneDeviceId], references: [id], onDelete: Cascade)
  latitude      Float
  longitude     Float
  altitude      Float?
  speed         Float?
  heading       Float?
  accuracy      Float?
  timestamp     DateTime
  createdAt     DateTime    @default(now())

  @@index([phoneDeviceId])
  @@index([timestamp])
  @@index([phoneDeviceId, timestamp])
}

// =====================
// FOUND OBJECT QR CHATS
// =====================

enum FoundChatStatus {
  ACTIVE
  RESOLVED   // Objeto recuperado
  CLOSED     // Chat cerrado
}

model FoundObjectChat {
  id              String          @id @default(uuid())
  deviceId        String
  device          Device          @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  ownerId         String          // Dueño del dispositivo
  owner           User            @relation("OwnedFoundChats", fields: [ownerId], references: [id], onDelete: Cascade)
  finderId        String?         // Usuario registrado que encontró (null si anónimo)
  finder          User?           @relation("FoundChats", fields: [finderId], references: [id], onDelete: SetNull)
  finderSessionId String?         // ID de sesión para usuarios anónimos
  finderName      String?         // Nombre opcional del que encontró
  status          FoundChatStatus @default(ACTIVE)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  messages        FoundObjectMessage[]

  @@index([deviceId])
  @@index([ownerId])
  @@index([finderId])
  @@index([finderSessionId])
  @@index([status])
}

model FoundObjectMessage {
  id        String          @id @default(uuid())
  chatId    String
  chat      FoundObjectChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  isOwner   Boolean         // true = mensaje del dueño, false = del que encontró
  content   String          @db.Text
  createdAt DateTime        @default(now())

  @@index([chatId])
  @@index([createdAt])
}
